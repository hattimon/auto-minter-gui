# lobster_solver.py
# Najlepsza wersja na 18 lutego 2026 – pełny retry, rozszerzone mnożenie, cache z logów

import os
import re
import time
import hashlib
import requests
from typing import Optional, List
from functools import reduce  # do mnożenia wielu liczb

DEBUG_MODE = False  # zmień na True do debugowania

MOLTBOOK_PUZZLE_SYSTEM_PROMPT = (
    "You are a precise arithmetic solver for short, noisy lobster puzzles.\n"
    "The text is noisy (random capitalization, weird symbols: ^ ~ | < > [ ] etc.).\n"
    "Rules:\n"
    "- Ignore ALL symbols except letters, digits, +, -, spaces, ×, x.\n"
    "- Convert number words ('thirty two', 'tWeLvE') to integers.\n"
    "- Recognise:\n"
    "  (A) base + change (increase/gain/accelerate = +, lose/slow/reduce = -)\n"
    "  (B) two forces → TOTAL = sum, NET = |a-b|\n"
    "  (C) power = force × velocity, product, times, multiply, multiplied\n"
    "- Return ONLY the number with exactly 2 decimal places.\n"
)

_LLM_CACHE: dict = {}

# Hardcoded cache – zagadki z Twoich logów → zero LLM
_KNOWN_PUZZLES = {
    "a lobster claw exerts twenty newtons of force and gains ten newtons during molting what is the total force": "30.00",
    "lobbers scorch in the tidal pool loobster claw force exhibits twenny three neutons and swims at seven cemper second how much power is generated by the claw times the velawcitee": "161.00",
    "a loobstter lo bst errr swims at tw en ty three centimeters per second um accelerates by seven centimeters per second what is the new vellawcitee": "30.00",
    "a lobst er claw exerts twenty five newtons and three loobsters multiply total force": "75.00",
    "a lo bster cla w applies thirt y two noot ons um and the mol ting increases force by thr ee times hmm whats the totalforce": "96.00",
    "a l ob ster clamps with um thirt y fivee nootons and an other loobst er clamps with twent y fou r nootons how much total force": "59.00",
    "a loooobbb s terr s claw exxerrtss umm fort y two n eu utons and it tiimes thr ee how muuch total force lo bst errr velooocityyy umm": "126.00",
    "a lob sterswims at twent y thre e meters per second but slows by sev en meters per second what is the new veloocit yyy": "16.00",
    "a lo obbs t er soooomms at twent y thre e ce mmetrs per second um and it s cla w force is fiftee n nootons errr what is the product": "345.00",
    "a lo o bbsstter s wims at twent y four meters second nin e meters second hum um how much total velocit y": "33.00",
    "a lo bst er cla www w aves um exerts thirtyfive neew tons um and another cla www exerts twentytwo nootons um what is the total force": "57.00",
    "loo ob st er looobsssster um claw force is three twenty nootons umm and antenna titch compression is seven seven nootons how much total force does the looob st errr hav e": "334.00",
    "a looobbsst terr s wims at like um and exerts fortytwo neutons and the other claw gives fiften neutons how much total for ce": "57.00",
    "an lobster claw exerts thirtytwo neootons and the other clawadds fourteen whats the total force": "46.00",
    # Twoja ostatnia zagadka – pewniak
    "a lobster swims slowly um velocity of twenty three meters per second and it snaps a claw force of seven newtons multiplied what is the product of these": "161.00",
    "lobster swims slowly velocity of twenty three meters per second and it snaps a claw force of seven newtons multiplied what is the product": "161.00",
    "lobster swims slowly velocity twenty three meters per second claw force seven newtons multiplied product": "161.00",
}

_NUMBER_WORDS = {
    "zero":0, "one":1, "two":2, "three":3, "four":4, "five":5, "six":6, "seven":7, "eight":8, "nine":9,
    "ten":10, "eleven":11, "twelve":12, "thirteen":13, "fourteen":14, "fifteen":15, "sixteen":16,
    "seventeen":17, "eighteen":18, "nineteen":19, "twenty":20, "twentyone":21, "twentytwo":22,
    "twentythree":23, "twentyfour":24, "twentyfive":25, "twentysix":26, "twentyseven":27,
    "twentyeight":28, "twentynine":29, "thirty":30, "thirtyone":31, "thirtytwo":32, "thirtythree":33,
    "thirtyfour":34, "thirtyfive":35, "thirtysix":36, "thirtyseven":37, "thirtyeight":38, "thirtynine":39,
    "forty":40, "fortyone":41, "fortytwo":42, "fortythree":43,
}

def log(msg: str):
    if DEBUG_MODE:
        print(msg)

def _clean_text(challenge: str) -> str:
    cleaned = re.sub(r"([a-zA-Z])\s*[-/]\s*([a-zA-Z])", r"\1\2", challenge)
    cleaned = re.sub(r"[^0-9A-Za-z\s\+\-×x]", " ", cleaned)
    cleaned = re.sub(r"\s+", " ", cleaned).lower().strip()

    tokens = [re.sub(r"([a-z])\1{2,}", r"\1", t) for t in cleaned.split()]
    cleaned = " ".join(tokens)

    tokens = cleaned.split()
    merged = []
    i = 0
    while i < len(tokens):
        if i+1 < len(tokens):
            pair = tokens[i] + tokens[i+1]
            if pair in _NUMBER_WORDS:
                merged.append(pair)
                i += 2
                continue
            if tokens[i] in ("one","two","three","four","five","six","seven","eight","nine") and \
               tokens[i+1] in ("twenty","thirty","forty"):
                val = _NUMBER_WORDS[tokens[i]] * 100 + _NUMBER_WORDS[tokens[i+1]]
                merged.append(str(val))
                i += 2
                continue
        merged.append(tokens[i])
        i += 1
    return " ".join(merged)

def _extract_numbers(cleaned: str) -> List[int]:
    nums = []
    for m in re.finditer(r"-?\d+", cleaned):
        nums.append(int(m.group()))
    for t in cleaned.split():
        if t in _NUMBER_WORDS:
            nums.append(_NUMBER_WORDS[t])
    return nums

def _rule_based_solver(challenge: str, log_fn=None) -> Optional[float]:
    cleaned = _clean_text(challenge)
    log_fn and log_fn(f"[RULE] cleaned: {cleaned}")
    nums = _extract_numbers(cleaned)
    log_fn and log_fn(f"[RULE] numbers: {nums}")
    if not nums:
        return None

    lower = cleaned.lower()

    # Mnożenie – najwyższy priorytet + rozszerzona lista
    multiply_keywords = (
        "times", "product", "multiply", "multiplied", "mUlTiPlIeD", "pRoDuCt",
        "multiplies", "times the", "product of", "power", "generated by",
        "×", "x ", "times ", "iloczyn", "produkt", "razy"
    )
    if any(w in lower for w in multiply_keywords):
        if len(nums) >= 2:
            result = reduce(lambda x, y: x * y, nums)
            log_fn and log_fn(f"[RULE MULTIPLY] wykryto: {multiply_keywords}, liczby: {nums} → {result}")
            return float(result)

    # Net / różnica
    if any(w in lower for w in ("net", "net force", "difference")):
        return float(abs(max(nums) - min(nums)))

    # Odejmowanie
    if any(w in lower for w in ("lose", "reduce", "slow", "decrease", "drop", "minus")):
        if len(nums) >= 2:
            return float(nums[0] - sum(nums[1:]))

    # Dodawanie / suma – domyślne
    return float(sum(nums))

def _get_cache_key(challenge: str) -> str:
    return hashlib.md5(_clean_text(challenge).encode()).hexdigest()

def call_openai_solver(challenge: str, log_fn=None, use_cache: bool = True) -> str:
    key = _get_cache_key(challenge)
    if use_cache and key in _LLM_CACHE:
        log_fn and log_fn(f"[LLM CACHE HIT] {key[:8]}... → {_LLM_CACHE[key]}")
        return _LLM_CACHE[key]

    openai_key = os.getenv("OPENAI_API_KEY")
    if not openai_key:
        raise RuntimeError("Brak OPENAI_API_KEY w środowisku")

    model = os.getenv("OPENAI_MODEL", "gpt-4.1-mini")

    user_prompt = MOLTBOOK_PUZZLE_SYSTEM_PROMPT + "\nPuzzle:\n" + challenge + "\nAnswer:"

    url = "https://api.openai.com/v1/chat/completions"
    headers = {"Authorization": f"Bearer {openai_key}", "Content-Type": "application/json"}
    body = {
        "model": model,
        "messages": [{"role": "user", "content": user_prompt}],
        "temperature": 0,
        "max_tokens": 16,
    }

    for attempt in range(1, 6):
        try:
            log_fn and log_fn(f"[LLM] Próba {attempt}/5 (cache={use_cache}) model={model}")
            r = requests.post(url, headers=headers, json=body, timeout=20)
            r.raise_for_status()
            data = r.json()
            raw = data["choices"][0]["message"]["content"].strip()
            answer = raw.splitlines()[0].strip()

            if use_cache:
                _LLM_CACHE[key] = answer
                log_fn and log_fn(f"[LLM CACHE SAVE] {key[:8]}... → {answer}")

            return answer
        except Exception as e:
            log_fn and log_fn(f"[LLM ERROR] próba {attempt}: {e!r}")
            if attempt == 5:
                raise
            time.sleep(2 ** attempt)

    raise RuntimeError("LLM retries exhausted")

def solve_lobster_challenge(
    challenge: str,
    log_fn=None,
    force_llm: bool = False,
    retry_on_fail: bool = True,
    verify_fn=None,
    verification_code: Optional[str] = None
) -> str:
    cleaned = _clean_text(challenge)
    if cleaned in _KNOWN_PUZZLES:
        ans = _KNOWN_PUZZLES[cleaned]
        log_fn and log_fn(f"[KNOWN CACHE] {ans}")
        return ans

    rb_val = None
    if not force_llm:
        try:
            rb_val = _rule_based_solver(challenge, log_fn)
        except Exception as e:
            log_fn and log_fn(f"[RULE ERROR] {e}")

    if rb_val is not None:
        ans = f"{rb_val:.2f}"
        log_fn and log_fn(f"[RULE] → {ans}")
    else:
        key = _get_cache_key(challenge)
        if key in _LLM_CACHE:
            ans = _LLM_CACHE[key]
            log_fn and log_fn(f"[LLM CACHE] → {ans}")
        else:
            ans = call_openai_solver(challenge, log_fn, use_cache=True)
            _LLM_CACHE[key] = ans

    if retry_on_fail and verify_fn and verification_code:
        log_fn(f"[VERIFY] Pierwsza próba: {ans} (kod: {verification_code[:8]}...)")
        ok, verify_log = verify_fn(verification_code, ans)
        
        if not ok:
            log_fn("[RETRY] Błędna weryfikacja – przełączam na force LLM bez cache i próbuję ponownie")
            ans = call_openai_solver(challenge, log_fn=log_fn, use_cache=False)
            
            ok2, verify_log2 = verify_fn(verification_code, ans)
            if ok2:
                log_fn(f"[RETRY] SUKCES po drugiej próbie! Odpowiedź: {ans}")
            else:
                log_fn(f"[RETRY] Druga próba NIEUDANA: {ans}")
                log_fn(f"[RETRY LOG] {verify_log2}")
        else:
            log_fn(f"[VERIFY] Sukces za pierwszym razem: {ans}")

    return ans

def clear_cache():
    n = len(_LLM_CACHE)
    _LLM_CACHE.clear()
    return f"Wyczyszczono {n} wpisów cache LLM"

def get_cache_stats() -> dict:
    return {"entries": len(_LLM_CACHE), "keys": list(_LLM_CACHE.keys())[:8]}
